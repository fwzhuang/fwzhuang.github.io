---
title: Introduction
tags: Vulkan
---

# Overview

* Vulkan的起源
* 画一个三角形需要什么
    *  步骤1 - 实例和物理设备的选择
    * 步骤2 - 逻辑设备和队列族
    * 第三步--窗面和交换链
    * 步骤4 - 图像视图和帧缓冲区
    * 步骤5 - 渲染通过
    * 步骤6 - 图形管道
    * 步骤7 - 命令池和命令缓冲区
    * 第八步 - 主回路
    * 摘要
* API概念
    * 编码惯例
    * 验证层

本章将首先介绍Vulkan和它所要解决的问题。之后，我们将看看第一个三角形所需要的成分。这将给你一个大局观，让你对后面的每一章都有一个大致的了解。最后，我们将介绍Vulkan API的结构和一般的使用模式。

## Vulkan的起源

就像之前的图形API一样，Vulkan被设计成了跨平台的GPU抽象。大多数这些API的问题在于，设计这些API的时代，其特点是图形硬件大多限于可配置的固定功能。程序员必须以标准格式提供顶点数据，在光照和阴影选项方面，GPU厂商只能任由其摆布。

随着显卡架构的成熟，它们开始提供越来越多的可编程功能。所有这些新功能都必须以某种方式与现有的API进行整合。这就导致了不太理想的抽象化和图形驱动方面的大量猜测工作，以将程序员的意图映射到现代图形架构上。这也是为什么会有那么多的驱动更新来提升游戏中的性能，有时会有很大的差距。由于这些驱动的复杂性，应用开发者还需要处理不同厂商之间的不一致，比如着色器所接受的语法等。除了这些新功能之外，过去十年来，拥有强大图形硬件的移动设备也涌入了大量的移动设备。这些移动GPU根据其能量和空间需求，有不同的架构。其中的一个例子就是图层渲染，通过为程序员提供更多的控制权，这将受益于性能的提升。另一个源于这些API时代的限制是有限的多线程支持，这可能导致CPU端出现瓶颈。

Vulkan通过为现代图形架构从头设计，解决了这些问题。它通过允许程序员使用更多的API来明确指定自己的意图，减少了驱动开销，并允许多线程并行创建和提交命令。它通过切换到一个标准化的字节码格式的单一编译器，减少了着色器编译中的不一致性。最后，它承认现代显卡的通用处理能力，将图形和计算功能统一到一个单一的API中。

## 画一个三角形需要什么
现在，我们来看看在Vulkan程序中渲染一个三角形的所有步骤。这里介绍的所有概念将在下一章中详细介绍。这只是为了给你提供一个大的画面，让你把所有的各个组件联系起来。

### 步骤1 - 实例和物理设备的选择

一个Vulkan应用程序通过VkInstance开始设置Vulkan API。通过描述您的应用程序和您将使用的任何API扩展来创建一个实例。创建实例后，你可以查询Vulkan支持的硬件，并选择一个或多个VkPhysicalDevices来进行操作。您可以查询Vulkan支持的属性，如VRAM大小和设备能力，以选择所需的设备，例如优先使用专用显卡。

### 步骤2 - 逻辑设备和队列系列

选择好要使用的硬件设备后，你需要创建一个VkDevice（逻辑设备），在这里你需要更具体地描述你要使用的VkPhysicalDeviceFeatures，比如多视口渲染和64位浮点。你还需要指定你想使用哪些队列族。使用Vulkan执行的大多数操作，如绘图命令和内存操作，都是通过提交到VkQueueue中异步执行的。队列是从队列族中分配的，每个队列族在其队列中支持一组特定的操作。例如，可以有单独的队列族来进行图形、计算和内存传输操作。队列族的可用性也可以作为物理设备选择的区分因素。支持Vulkan的设备有可能不提供任何图形功能，但是目前所有支持Vulkan的显卡一般都会支持我们感兴趣的所有队列操作。

### 第三步--窗口面和交换链

除非你只对离屏渲染感兴趣，否则你需要创建一个窗口来呈现渲染后的图像。窗口可以通过原生平台API或GLFW和SDL等库来创建。我们将在本教程中使用GLFW，但更多的内容将在下一章介绍。

我们还需要两个组件来实际渲染到一个窗口：一个窗口曲面（VkSurfaceKHR）和一个交换链（VkSwapchainKHR）。请注意KHR后缀，这意味着这些对象是Vulkan扩展的一部分。Vulkan API本身是完全不依赖于平台的，这就是为什么我们需要使用标准化的WSI（Window System Interface）扩展来与窗口管理器交互的原因。曲面是一个跨平台的抽象，它是一个跨平台的窗口抽象，要渲染到的窗口，一般是通过提供原生窗口句柄的引用来实例化，例如Windows上的HWND。幸运的是，GLFW库内置了一个函数来处理平台上的具体细节。

交换链是一个渲染目标的集合。它的基本目的是确保我们当前渲染的图像与当前屏幕上的图像不同。这对于确保只显示完整的图像是很重要的。每当我们想绘制一个帧时，我们必须要求交换链为我们提供一个要渲染的图像。当我们绘制完一个帧后，图像会返回给交换链，让它在某个时候呈现在屏幕上。渲染目标的数量和将完成的图像呈现到屏幕上的条件取决于呈现模式。常见的呈现模式有双缓冲（vsync）和三缓冲。我们将在交换链创建章节中研究这些模式。

有些平台允许你通过VK_KHR_display和VK_KHR_display_swapchain扩展，直接渲染到显示器而不与任何窗口管理器交互。这些扩展允许你创建一个代表整个屏幕的曲面，可以用来实现你自己的窗口管理器，例如。

### 第四步 - 图像视图和帧缓冲区

为了绘制到从交换链中获取的图像，我们必须将其封装成VkImageView和VkFramebuffer。一个图像视图引用了要使用的图像的特定部分，而framebuffer引用了要用于颜色、深度和模板目标的图像视图。因为在交换链中可能有许多不同的图像，我们将为每个图像预先创建一个图像视图和framebuffer，并在绘制时选择合适的图像视图。

### 第5步--渲染通过

Vulkan中的渲染传递描述了在渲染操作过程中使用的图像类型、如何使用它们，以及应该如何处理它们的内容。在我们最初的三角形渲染应用中，我们将告诉Vulkan我们将使用一个单一的图像作为颜色目标，并且我们希望在绘制操作之前将其清除为纯色。而渲染通只描述了图像的类型，而VkFramebuffer实际上是将特定的图像绑定到这些插槽上。

### 第6步--图形流水线

Vulkan中的图形管道是通过创建一个VkPipeline对象来设置的。它描述了显卡的可配置状态，如视口大小和深度缓冲区的操作，以及使用VkShaderModule对象的可编程状态。VkShaderModule对象是由着色器字节代码创建的。驱动程序还需要知道流水线中会使用哪些渲染目标，我们通过引用渲染通来指定。

与现有的API相比，Vulkan最显著的特点之一是，几乎所有的图形管道的配置都需要提前设置。这就意味着，如果你想切换到不同的着色器或者稍微改变一下顶点布局，那么你需要完全重新创建图形管道。这就意味着，你必须提前创建许多VkPipeline对象，以满足你的渲染操作所需要的所有不同组合。只有一些基本的配置，如视口大小和清除颜色等基本配置可以动态改变。所有的状态也需要明文描述，比如说没有默认的颜色混合状态。

好消息是，由于你所做的是相当于超前编译，而不是即时编译，所以驱动有更多的优化机会，而且运行时的性能也更有预见性，因为大的状态变化，比如切换到不同的图形管道，都是非常显式的。

### 第七步 - 命令池和命令缓冲区
如前所述，在Vulkan中，我们要执行的很多操作，比如绘图操作，都需要提交到队列中。这些操作首先需要记录到VkCommandBuffer中，然后才能提交。这些命令缓冲区是从与特定队列族关联的VkCommandPool中分配的。为了绘制一个简单的三角形，我们需要用以下操作记录一个命令缓冲区。
* 开始渲染传递
* 绑定图形管线
* 画出3个顶点
* 结束渲染通过

因为framebuffer中的图像取决于交换链将给我们的具体图像，所以我们需要为每一个可能的图像记录一个命令缓冲区，并在绘制时选择合适的图像。另一种方法是每帧都要重新记录命令缓冲区，这样做的效率并不高。

### 步骤8 - 主循环

现在绘图命令已经被封装到了命令缓冲区中，主循环就很直接了。我们首先用vkAcquireNextImageKHR从交换链中获取一个图像。然后，我们可以为该图像选择合适的命令缓冲区，用vkQueueSubmit执行。最后，我们用vkQueuePresentKHR将该图像返回到交换链中，然后用vkQuePresentKHR将其呈现到屏幕上。

提交到队列中的操作是异步执行的。因此我们必须使用信号量等同步对象来保证执行顺序的正确性。绘制命令缓冲区的执行必须设置为等待图像采集完成后再执行，否则可能会出现我们开始渲染到屏幕上还在读取图像进行呈现的情况。而vkQueuePresentKHR调用也需要等待渲染完成，为此我们将使用第二个信号量，在渲染完成后发出信号。

后面的章节中涉及到，但我们将从简单的步骤开始，因为Vulkan的学习曲线已经足够陡峭了。需要注意的是，我们将通过最初将顶点坐标嵌入到顶点着色器中而不是使用顶点缓冲区来作弊。这是因为管理顶点缓冲区需要先对命令缓冲区有一定的熟悉度。

所以简单来说，要绘制第一个三角形，我们需要。
* 创建一个VkInstance
* 选择支持的显卡（VkPhysicalDevice）。
* 创建一个VkDevice和VkQueueue，用于绘图和演示。
* 建立一个窗口、窗口面和交换链。
* 将交换链图像封装到VkImageView中。
* 创建一个渲染通道，指定渲染目标和使用方法。
* 为渲染通道创建 framebuffers
* 设置图形管线
* 为每个可能的交换链图像分配和记录一个命令缓冲区，并为每个可能的交换链图像分配和记录命令缓冲区。
* 通过获取图像，提交正确的绘制命令缓冲区，并将图像返回到交换链上，从而绘制出帧。

虽然步骤很多，但每一个步骤的目的，在接下来的章节中都会讲得非常简单明了。如果你对单个步骤与整个程序的关系感到困惑，可以参考本章的内容。

## API的概念

本章最后将简要介绍Vulkan API在底层的结构。

### 编码约定

所有的Vulkan函数、枚举和结构都定义在vulkan.h头中，它包含在LunarG开发的Vulkan SDK中。我们将在下一章中研究安装这个SDK。

函数有一个小写的vk前缀，像枚举和structs这样的类型有一个Vk前缀，而枚举值有一个VK_前缀。API大量使用结构体来为函数提供参数。例如，对象的创建一般遵循这样的模式。

```
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```

Vulkan中的许多结构都要求你在sType成员中明确指定结构的类型。pNext成员可以指向一个扩展结构，并且在本教程中始终是nullptr。创建或销毁对象的函数会有一个VkAllocationCallbacks参数，该参数允许你使用驱动内存的自定义分配器，在本教程中也会留下nullptr。

几乎所有的函数都会返回一个VkResult，这个VkResult要么是VK_SUCCESS，要么是错误代码。本规范描述了每个函数可以返回哪些错误代码以及它们的含义。

### 验证层
如前所述，Vulkan是为高性能和低驱动开销而设计的。因此它默认情况下会包含非常有限的错误检查和调试功能。如果你做错了什么，驱动程序经常会崩溃，而不是返回错误代码，或者更糟糕的是，它将在你的显卡上显示工作，而在其他显卡上完全失败。

Vulkan允许你通过一种称为验证层的功能来启用广泛的检查功能。验证层是可以插入到API和图形驱动之间的代码，用于对函数参数进行额外的检查和跟踪内存管理问题等。好在你可以在开发过程中启用它们，然后在发布应用程序时完全禁用它们，这样做的好处是零开销。任何人都可以编写自己的验证层，但LunarG的Vulkan SDK提供了一组标准的验证层，我们在本教程中会用到。你还需要注册一个回调函数来接收来自层的调试消息。

因为Vulkan对每一个操作都非常明确，而且验证层也非常广泛，所以相比于OpenGL和Direct3D来说，要找出你的屏幕为什么会黑的原因，其实可以轻松很多！不过，如果你想知道你的屏幕为什么会黑，那就需要你自己去找。

在我们开始写代码之前，只剩下一个步骤了，那就是设置开发环境。


If you like Text, don't forget to give me a star. :star2:

[![Star This Project](https://img.shields.io/github/stars/kitian616/jekyll-TeXt-theme.svg?label=Stars&style=social)](https://github.com/fwzhuang/fwzhuang.github.io)