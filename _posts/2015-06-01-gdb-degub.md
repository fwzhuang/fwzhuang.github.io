---
layout: post
title: GDB tutorials
categories: [Linux]
description: GBD调试入门
keywords: C++, GDB
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---

GDB 调试入门

<!--more-->

## 概述
天下三分, 三足鼎立. windows系, linux系, OS X系, 江湖上人称三侠客.  
三侠客中,各有千秋, 其中window系长得帅,粉丝众多, 一把绝世宝刀VS,练得得心应手.而OS X系有钱, 传言道, 其深藏不露, 神龙见首不见尾.唯独Linux兄, 行走于江湖, 江湖上都有其传说. 一把轻剑在手,名叫gdb, 遇神杀神, 遇鬼灭鬼.

谈起gdb, 这是一把令人闻风丧胆的利器. 传说其厉害之处在于:  
1. 与程序君对敌, 当程序君放出大招core dump时， gdb剑可找到程序君是哪里有缺陷(在什么语句或表达式崩溃的了)．  
2. 如果在执行函数时发生错误， 通过gdb找到哪一行调用到函数，以及参数是什么．  
3. 知道程序在执行期间的变量值是什么.  
4. 程序的表达式结果是什么.  
5. ......  

^_^ 编不下去了....  
言归正传, 如何通过gdb调试代码,才是主要的关注内容.  
在linux系统中,一般都自带安装了gdb调试器. gdb调试过程中,需要通过调试符号表将编译的二进制程序中的指令映射到源代码中的相应变量，函数或行。符号调试器是运行程序的应用程序，就像您可以输入程序名称一样。不同之处在于，调试器可以逐行浏览您的源代码，仅在需要时执行每行。为什么要用gdb调试器呢,有的会就会提出疑问,我可以用printf来打印相关的变量值,从而进行调试啊? 是的,但这是一种最低效的方法,等你学完了此教程,你就会发现gdb这小子的优点,并且喜欢上他...

**不什么不用printf ?**  
大多数人使用printf（）调试方法。这称为将“跟踪代码”添加到您的程序。简单地说，他们使用printf（）来调用他们的代码，以便在某些关键点查看变量的值，并检查源代码行的执行顺序。  
有几个原因为什么这可能不是最好的做事方式：  

-  有时你需要大量的printf（），它可以让人厌烦的把它们拿出来。插入和删除多余的代码所有的时间真的分心。
-  符号调试器可以做很多，printf()不能。你可以做任何你想到的事情，包括在运行时改变变量的值，暂时停止程序，列出源代码，打印一个变量或结构的数据类型，你不认识，跳到任意代码行，以及更多...
- 您可以在正在运行的进程上使用符号调试器;你甚至不必杀死无师自通！
- 您可以对已经崩溃并死亡的进程使用符号调试器，而无需重新运行程序。你会看到程序在死亡时的状态，并可以检查所有的变量。
- 你将能够使用像GDB这样的符号调试器更快地找到并修复你的错误。但是，这不是说printf()在调试中没有用。有时它是最好的方式。然而，对于真正的代码，调试器几乎总是可以使工作完成数量级更快更容易。使用调试器总是更优雅，如果你不在乎优雅，你应该退出在Linux上的编程，并开始使用Visual C ++。

入门之前， 先进学前班吧

**内存布局和堆栈**

要有效地学习如何使用GDB，你必须理解堆栈帧，因为它们是构成堆栈的帧。要了解堆栈，我们需要了解一个正在执行的程序的内存布局。

1. 了解堆栈对于使用像GDB这样的符号调试器是绝对必要的。
2. 知道一个进程的内存布局将有助于我们了解什么是segmentation fault(程序中最怕出现的问题之一)，以及为什么它们发生或者为什么譔发生时不发生。简而言之，段错误是程序炸弹的最常见的直接原因。
3. 知道程序的内存空间通常可以让我们找出隐藏的bug的位置，而不使用print()语句，编译器甚至GDB！

**虚拟内存（VM）**

每当一个进程被创建时，内核提供一块物理内存，它可以位于任何地方。然而，通过虚拟内存（VM）的魔力，进程认为它拥有计算机上的所有内存， 你可能听说过“虚拟内存”， 即当RAM用完时，可能使用硬盘空间作为内存，这也被称为虚拟内存。然而，这些都是闲扯的，我们真正关心的是VM的以下几点构造原则：

- 每个进程都被赋予物理内存，称为进程的虚拟内存空间。
- 进程不知道其物理存储器的细节（即其物理驻留的位置）。所有的进程知道块是多大，它的块从地址0开始。
- 每个进程不知道属于其他进程的VM数量。
- 尽管进程知道VM的数量，但它已经从物理上被阻止访问该内存。

每次进程要读取或写入内存时，其请求都必须从VM地址转换为物理内存地址。相反，当内核需要访问进程的VM时，它必须将物理内存地址转换为VM地址。这里有两个主要问题：

- 计算机经常访问内存，所以VM与物理内存的转换过程需要非常快。
- 操作系统如何确保进程不会破坏另一个进程的VM？

这两个问题的答案在于：操作系统本身不管理VM的事实;它从CPU获得帮助。许多CPU包含称为内存管理单元（MMU）的设备。 MMU和操作系统共同负责管理VM，在虚拟内存和物理内存地址之间进行转换，从而保证进程间访问内存能够不冲突，以及对VM空间块的读写权限，甚至包括拥有该VM空间的进程。


